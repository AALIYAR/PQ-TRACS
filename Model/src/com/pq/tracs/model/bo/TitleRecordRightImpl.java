package com.pq.tracs.model.bo;

import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;

import oracle.jbo.AttributeList;
import oracle.jbo.JboException;
import oracle.jbo.Key;
import oracle.jbo.Row;
import oracle.jbo.RowIterator;
import oracle.jbo.RowSet;
import oracle.jbo.domain.Date;
import oracle.jbo.domain.Number;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.SequenceImpl;
import oracle.jbo.server.TransactionEvent;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class TitleRecordRightImpl extends TracsBaseEntity {
    private static EntityDefImpl mDefinitionObject;
    
    private RightTemplateImpl template;
    
    private int currentOp;

    /**
     * Add attribute defaulting logic in this method.
     * @param attributeList list of attribute names/values to initialize the row
     */
    protected void create(AttributeList attributeList) {
        super.create(attributeList);
        
        this.setGenerationMethod("Manual");
    }

    /**
     * AttributesEnum: generated enum for identifying attributes and accessors. Do not modify.
     */
    public enum AttributesEnum {
        Id {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getId();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setId((Number)value);
            }
        }
        ,
        TitleRecordId {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getTitleRecordId();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setTitleRecordId((Number)value);
            }
        }
        ,
        RuleNumber {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getRuleNumber();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setRuleNumber((String)value);
            }
        }
        ,
        TranslationFlag {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getTranslationFlag();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setTranslationFlag((String)value);
            }
        }
        ,
        PublicationStartDate {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getPublicationStartDate();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setPublicationStartDate((Date)value);
            }
        }
        ,
        PublicationEndDate {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getPublicationEndDate();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setPublicationEndDate((Date)value);
            }
        }
        ,
        EmbargoDays {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getEmbargoDays();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setEmbargoDays((Number)value);
            }
        }
        ,
        ReverseEmbargoDays {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getReverseEmbargoDays();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setReverseEmbargoDays((Number)value);
            }
        }
        ,
        CreatedBy {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getCreatedBy();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setCreatedBy((String)value);
            }
        }
        ,
        CreatedDate {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getCreatedDate();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setCreatedDate((Date)value);
            }
        }
        ,
        LastUpdatedBy {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getLastUpdatedBy();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setLastUpdatedBy((String)value);
            }
        }
        ,
        LastUpdatedDate {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getLastUpdatedDate();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setLastUpdatedDate((Date)value);
            }
        }
        ,
        RightType {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getRightType();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setRightType((String)value);
            }
        }
        ,
        RightTemplateId {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getRightTemplateId();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setRightTemplateId((Number)value);
            }
        }
        ,
        CompleteFlag {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getCompleteFlag();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setCompleteFlag((String)value);
            }
        }
        ,
        GenerationMethod {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getGenerationMethod();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setGenerationMethod((String)value);
            }
        }
        ,
        TitleRecord {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getTitleRecord();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setTitleRecord((TitleRecordImpl)value);
            }
        }
        ,
        TitleRecordRightCategory {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getTitleRecordRightCategory();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setAttributeInternal(index(), value);
            }
        }
        ,
        RightTemplate {
            public Object get(TitleRecordRightImpl obj) {
                return obj.getRightTemplate();
            }

            public void put(TitleRecordRightImpl obj, Object value) {
                obj.setRightTemplate((RightTemplateImpl)value);
            }
        }
        ;
        private static AttributesEnum[] vals = null;
        private static int firstIndex = 0;

        public abstract Object get(TitleRecordRightImpl object);

        public abstract void put(TitleRecordRightImpl object, Object value);

        public int index() {
            return AttributesEnum.firstIndex() + ordinal();
        }

        public static int firstIndex() {
            return firstIndex;
        }

        public static int count() {
            return AttributesEnum.firstIndex() + AttributesEnum.staticValues().length;
        }

        public static AttributesEnum[] staticValues() {
            if (vals == null) {
                vals = AttributesEnum.values();
            }
            return vals;
        }
    }


    public static final int ID = AttributesEnum.Id.index();
    public static final int TITLERECORDID = AttributesEnum.TitleRecordId.index();
    public static final int RULENUMBER = AttributesEnum.RuleNumber.index();
    public static final int TRANSLATIONFLAG = AttributesEnum.TranslationFlag.index();
    public static final int PUBLICATIONSTARTDATE = AttributesEnum.PublicationStartDate.index();
    public static final int PUBLICATIONENDDATE = AttributesEnum.PublicationEndDate.index();
    public static final int EMBARGODAYS = AttributesEnum.EmbargoDays.index();
    public static final int REVERSEEMBARGODAYS = AttributesEnum.ReverseEmbargoDays.index();
    public static final int CREATEDBY = AttributesEnum.CreatedBy.index();
    public static final int CREATEDDATE = AttributesEnum.CreatedDate.index();
    public static final int LASTUPDATEDBY = AttributesEnum.LastUpdatedBy.index();
    public static final int LASTUPDATEDDATE = AttributesEnum.LastUpdatedDate.index();
    public static final int RIGHTTYPE = AttributesEnum.RightType.index();
    public static final int RIGHTTEMPLATEID = AttributesEnum.RightTemplateId.index();
    public static final int COMPLETEFLAG = AttributesEnum.CompleteFlag.index();
    public static final int GENERATIONMETHOD = AttributesEnum.GenerationMethod.index();
    public static final int TITLERECORD = AttributesEnum.TitleRecord.index();
    public static final int TITLERECORDRIGHTCATEGORY = AttributesEnum.TitleRecordRightCategory.index();
    public static final int RIGHTTEMPLATE = AttributesEnum.RightTemplate.index();

    /**This is the default constructor (do not remove)
     */
    public TitleRecordRightImpl() {
    }


    /**
     * @return the definition object for this instance class.
     */
    public static synchronized EntityDefImpl getDefinitionObject() {
        if (mDefinitionObject == null) {
            mDefinitionObject = EntityDefImpl.findDefObject("com.pq.tracs.model.bo.TitleRecordRight");
        }
        return mDefinitionObject;
    }

    /**Gets the attribute value for Id, using the alias name Id
     */
    public Number getId() {
        return (Number)getAttributeInternal(ID);
    }

    /**Sets <code>value</code> as the attribute value for Id
     */
    public void setId(Number value) {
        setAttributeInternal(ID, value);
    }

    /**Gets the attribute value for TitleRecordId, using the alias name TitleRecordId
     */
    public Number getTitleRecordId() {
        return (Number)getAttributeInternal(TITLERECORDID);
    }

    /**Sets <code>value</code> as the attribute value for TitleRecordId
     */
    public void setTitleRecordId(Number value) {
        setAttributeInternal(TITLERECORDID, value);
    }


    /**Gets the attribute value for RuleNumber, using the alias name RuleNumber
     */
    public String getRuleNumber() {
        return (String)getAttributeInternal(RULENUMBER);
    }

    /**Sets <code>value</code> as the attribute value for RuleNumber
     */
    public void setRuleNumber(String value) {
        setAttributeInternal(RULENUMBER, value);
    }


    /**Gets the attribute value for TranslationFlag, using the alias name TranslationFlag
     */
    public String getTranslationFlag() {
        return (String)getAttributeInternal(TRANSLATIONFLAG);
    }

    /**Sets <code>value</code> as the attribute value for TranslationFlag
     */
    public void setTranslationFlag(String value) {
        setAttributeInternal(TRANSLATIONFLAG, value);
    }


    /**Gets the attribute value for PublicationStartDate, using the alias name PublicationStartDate
     */
    public Date getPublicationStartDate() {
        return (Date)getAttributeInternal(PUBLICATIONSTARTDATE);
    }

    /**Sets <code>value</code> as the attribute value for PublicationStartDate
     */
    public void setPublicationStartDate(Date value) {
        setAttributeInternal(PUBLICATIONSTARTDATE, value);
    }

    /**Gets the attribute value for PublicationEndDate, using the alias name PublicationEndDate
     */
    public Date getPublicationEndDate() {
        return (Date)getAttributeInternal(PUBLICATIONENDDATE);
    }

    /**Sets <code>value</code> as the attribute value for PublicationEndDate
     */
    public void setPublicationEndDate(Date value) {
        setAttributeInternal(PUBLICATIONENDDATE, value);
    }

    /**Gets the attribute value for EmbargoDays, using the alias name EmbargoDays
     */
    public Number getEmbargoDays() {
        return (Number)getAttributeInternal(EMBARGODAYS);
    }

    /**Sets <code>value</code> as the attribute value for EmbargoDays
     */
    public void setEmbargoDays(Number value) {
        setAttributeInternal(EMBARGODAYS, value);
    }

    /**Gets the attribute value for ReverseEmbargoDays, using the alias name ReverseEmbargoDays
     */
    public Number getReverseEmbargoDays() {
        return (Number)getAttributeInternal(REVERSEEMBARGODAYS);
    }

    /**Sets <code>value</code> as the attribute value for ReverseEmbargoDays
     */
    public void setReverseEmbargoDays(Number value) {
        setAttributeInternal(REVERSEEMBARGODAYS, value);
    }

    /**Gets the attribute value for CreatedBy, using the alias name CreatedBy
     */
    public String getCreatedBy() {
        return (String)getAttributeInternal(CREATEDBY);
    }


    /**
     * Sets <code>value</code> as the attribute value for CreatedBy.
     * @param value value to set the CreatedBy
     */
    public void setCreatedBy(String value) {
        setAttributeInternal(CREATEDBY, value);
    }

    /**Gets the attribute value for CreatedDate, using the alias name CreatedDate
     */
    public Date getCreatedDate() {
        return (Date)getAttributeInternal(CREATEDDATE);
    }


    /**
     * Sets <code>value</code> as the attribute value for CreatedDate.
     * @param value value to set the CreatedDate
     */
    public void setCreatedDate(Date value) {
        setAttributeInternal(CREATEDDATE, value);
    }

    /**Gets the attribute value for LastUpdatedBy, using the alias name LastUpdatedBy
     */
    public String getLastUpdatedBy() {
        return (String)getAttributeInternal(LASTUPDATEDBY);
    }

    /**Sets <code>value</code> as the attribute value for LastUpdatedBy
     */
    public void setLastUpdatedBy(String value) {
        setAttributeInternal(LASTUPDATEDBY, value);
    }

    /**Gets the attribute value for LastUpdatedDate, using the alias name LastUpdatedDate
     */
    public Date getLastUpdatedDate() {
        return (Date)getAttributeInternal(LASTUPDATEDDATE);
    }


    /**
     * Sets <code>value</code> as the attribute value for LastUpdatedDate.
     * @param value value to set the LastUpdatedDate
     */
    public void setLastUpdatedDate(Date value) {
        setAttributeInternal(LASTUPDATEDDATE, value);
    }

    /**getAttrInvokeAccessor: generated method. Do not modify.
     */
    protected Object getAttrInvokeAccessor(int index, 
                                           AttributeDefImpl attrDef) throws Exception {
        if ((index >= AttributesEnum.firstIndex()) && (index < AttributesEnum.count())) {
            return AttributesEnum.staticValues()[index - AttributesEnum.firstIndex()].get(this);
        }
        return super.getAttrInvokeAccessor(index, attrDef);
    }

    /**setAttrInvokeAccessor: generated method. Do not modify.
     */
    protected void setAttrInvokeAccessor(int index, Object value, 
                                         AttributeDefImpl attrDef) throws Exception {
        if ((index >= AttributesEnum.firstIndex()) && (index < AttributesEnum.count())) {
            AttributesEnum.staticValues()[index - AttributesEnum.firstIndex()].put(this, value);
            return;
        }
        super.setAttrInvokeAccessor(index, value, attrDef);
    }

    /**Gets the associated entity TitleRecordImpl
     */
    public TitleRecordImpl getTitleRecord() {
        return (TitleRecordImpl)getAttributeInternal(TITLERECORD);
    }

    /**Sets <code>value</code> as the associated entity TitleRecordImpl
     */
    public void setTitleRecord(TitleRecordImpl value) {
        setAttributeInternal(TITLERECORD, value);
    }


    /**Gets the attribute value for RightType, using the alias name RightType
     */
    public String getRightType() {
        return (String)getAttributeInternal(RIGHTTYPE);
    }

    /**Sets <code>value</code> as the attribute value for RightType
     */
    public void setRightType(String value) {
        setAttributeInternal(RIGHTTYPE, value);
    }

    /**Gets the attribute value for RightTemplateId, using the alias name RightTemplateId
     */
    public Number getRightTemplateId() {
        return (Number)getAttributeInternal(RIGHTTEMPLATEID);
    }

    /**Sets <code>value</code> as the attribute value for RightTemplateId
     */
    public void setRightTemplateId(Number value) {
        setAttributeInternal(RIGHTTEMPLATEID, value);
    }

    public void copyTemplate () {
        try {
            RowIterator categories = template.getRightCategoryTemplate();
            while (categories.hasNext()) {
                Row category = categories.next();
                
                Row newCat = this.getTitleRecordRightCategory().createRow();
                newCat.setAttribute("TitleRecordRightId", getId());
                newCat.setAttribute("CategoryId", category.getAttribute("CategoryId"));
                newCat.setAttribute("Value", category.getAttribute("Value"));
                newCat.setAttribute("PermitFlag", category.getAttribute("PermitFlag"));
                getTitleRecordRightCategory().insertRow(newCat);
            }
        }
        catch (Exception ex) {
            throw new JboException("Unable to apply template categories.  " + ex.getMessage());
        }
    }

    protected void prepareForDML(int operation, TransactionEvent e) {
        currentOp = operation;
        
        super.prepareForDML(operation,e);

        try {
            if (operation == DML_INSERT) {
                SequenceImpl seq = new SequenceImpl("TRAX_RULE_NUMBER_SEQ",getDBTransaction());
                int seqNo = seq.getSequenceNumber().intValue();
                String prefix = "D";
                
                if("Blocking Rule".equals(getRightType()))
                    prefix = "B";
                else if("Restriction".equals(getRightType()))
                    prefix = "R";

                setRuleNumber(prefix +"-" + seqNo);
                
                if (getRightTemplateId() != null) {
                    template = getRightTemplate();
                    this.setRightTemplateId(null);
                    copyTemplate();
                    
                    this.setCompleteFlag("Y");
                }
                
            }
            else if (operation == DML_UPDATE) {
                this.setCompleteFlag("Y");
            }
        }catch(Exception eee){}
        
    }
    
    protected void doDML(int operation, TransactionEvent e) {
        super.doDML(operation, e);
        
    }
   
    public void afterCommit(TransactionEvent e) {
        super.afterCommit(e);
        
        
        if (currentOp == DML_INSERT && template == null) {
            FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Right Incomplete", "The Right was saved but is incomplete.  Please add at least one Delivery Format and at least one Delivery Method in the Categories."));
            
        } else {
            template = null;
        }
        
        currentOp = -1;
       
    }  // end afterCommit

    /**Validation method for TraxTitleRecordRight
     */
    public boolean validateTraxTitleRecordRight() {
        // check that the start and end dates of the right exist and that the end >= the start
        if (getRightType().equalsIgnoreCase("delivery right"))
        {
            Date startDate = getPublicationStartDate();
            Date endDate = getPublicationEndDate();
            if (startDate == null || endDate == null) {
                return false;
            }
            else if (endDate.compareTo(startDate) < 0 )
            {
                return false;
            }
        }
        
        return true;
    }  
  

    /**Gets the attribute value for CompleteFlag, using the alias name CompleteFlag
     */
    public String getCompleteFlag() {
        return (String)getAttributeInternal(COMPLETEFLAG);
    }

    /**Sets <code>value</code> as the attribute value for CompleteFlag
     */
    public void setCompleteFlag(String value) {
        setAttributeInternal(COMPLETEFLAG, value);
    }

    /**
     * Gets the attribute value for GenerationMethod, using the alias name GenerationMethod.
     * @return the GenerationMethod
     */
    public String getGenerationMethod() {
        return (String)getAttributeInternal(GENERATIONMETHOD);
    }

    /**
     * Sets <code>value</code> as the attribute value for GenerationMethod.
     * @param value value to set the GenerationMethod
     */
    public void setGenerationMethod(String value) {
        setAttributeInternal(GENERATIONMETHOD, value);
    }

    /**Validation method for TraxTitleRecordRight
     */
    public boolean validateTraxTitleRecordRightMethod() {
        if ((this.getEntityState() != this.STATUS_NEW && this.getEntityState() != this.STATUS_DEAD && this.getEntityState() != this.STATUS_DELETED)
            && (this.getRightType().equalsIgnoreCase("delivery right"))
        ) {
            RowSet categories = (RowSet)getTitleRecordRightCategory();
            boolean hasMethod = false;
            
            if (categories != null) {
                while (categories.hasNext()) {
                    TitleRecordRightCategoryImpl category = (TitleRecordRightCategoryImpl)categories.next();
                    if (category.getCategoryId().compareTo(2) == 0) {
                        hasMethod = true;
                    }
                }   // end while
            }
            
            if (!hasMethod) {
                // the Right is not complete
                return false;
            }
        }
        return true;
    }

    /**Validation method for TraxTitleRecordRight
     */
    public boolean validateTraxTitleRecordRightFormat() {
        if ((this.getEntityState() != this.STATUS_NEW && this.getEntityState() != this.STATUS_DEAD && this.getEntityState() != this.STATUS_DELETED)
            && (this.getRightType().equalsIgnoreCase("delivery right") || this.getRightType().equalsIgnoreCase("restriction"))
        ) {
            RowSet categories = (RowSet)getTitleRecordRightCategory();
            boolean hasFormat = false;
            
            if (categories != null) {
                while (categories.hasNext()) {
                    TitleRecordRightCategoryImpl category = (TitleRecordRightCategoryImpl)categories.next();
                    if (category.getCategoryId().compareTo(1) == 0) {
                        hasFormat = true;
                    }
                }   // end while
            }
            
            if (!hasFormat) {
                // the Right is not complete
                return false;
            }
        }
        
        return true;
    }

    /**Validation method for TraxTitleRecordRight
     */
    public boolean validateTraxTitleRecordRightOverlap() {
        if (((this.getEntityState() != this.STATUS_NEW || (this.getRightTemplateId() != null || template != null)) 
            && this.getEntityState() != this.STATUS_DEAD && this.getEntityState() != this.STATUS_DELETED)
            && (this.getRightType().equalsIgnoreCase("delivery right"))
        ) {
            // no overlap to start
            boolean overlap = false;
            
            RowIterator categories;

            if (template == null && this.getRightTemplateId() == null) {
                // pull the categories for the current right
                categories = this.getTitleRecordRightCategory();
            } else if (template != null) {
                categories = template.getRightCategoryTemplate();
            } else {
                categories = this.getRightTemplate().getRightCategoryTemplate();
            }
            
            // if the current right has no categories, or only 1 category, there can be no overlap
            if (categories.getRowCount() > 1) {
                // pull the date and embargo fields for the current right
                Date startDate = this.getPublicationStartDate();
                Date endDate = this.getPublicationEndDate();
                Number embargo;
                Number reverse;
                
                // if the embargo fields are null, update them to 0
                if (this.getEmbargoDays() == null) {
                    embargo = new Number(0);
                } else {
                    embargo = this.getEmbargoDays();
                }
                if (this.getReverseEmbargoDays() == null) {
                    reverse = new Number(0);
                } else {
                    reverse = this.getReverseEmbargoDays();
                }
                                
                // pull al the rights for the current title record
                RowIterator rights = this.getTitleRecord().getTitleRecordRight();
                while (rights.hasNext()) {
                    TitleRecordRightImpl right = (TitleRecordRightImpl)rights.next();
                    
                    // check that we aren't comparing the right to itself
                    if (right.getRuleNumber() != null && !right.getRuleNumber().equalsIgnoreCase(this.getRuleNumber()) 
                        && right.getRightType().equalsIgnoreCase("delivery right")) {

                        // pull the dates and embargoes for the right being compared
                        Date rightStartDate = right.getPublicationStartDate();
                        Date rightEndDate = right.getPublicationEndDate();
                        Number rightEmbargo = right.getEmbargoDays();
                        Number rightReverse = right.getReverseEmbargoDays();   
                        
                        // update embargoes from null to 0
                        if (right.getEmbargoDays() == null) {
                            rightEmbargo = new Number(0);
                        } else {
                            rightEmbargo = right.getEmbargoDays();
                        }
                        if (right.getReverseEmbargoDays() == null) {
                            rightReverse = new Number(0);
                        } else {
                            rightReverse = right.getReverseEmbargoDays(); 
                        }

                        // if the start date or the end date for the current right is between the start and end date for the compared right (inclusive)
                        // or the old rights dates are between those for the new right
                        // there may be an overlap and we need to check the embargoes, formats and methods.
                        if ( // new start date is between old dates OR new end date is betweend old dates
                            (startDate.compareTo(rightStartDate) >= 0 && startDate.compareTo(rightEndDate) <= 0)
                                || (endDate.compareTo(rightStartDate) >= 0 && endDate.compareTo(rightEndDate) <= 0)
                                || (rightStartDate.compareTo(startDate) >= 0 && rightStartDate.compareTo(endDate) <= 0)
                                || (rightEndDate.compareTo(startDate) >= 0 && rightEndDate.compareTo(endDate) <= 0)) 
                        {
                            boolean embargoOverlap = false;
                            if (// embargoes are both > 0
                                (embargo.compareTo(0) == 1 && rightEmbargo.compareTo(0) == 1)
                                || // OR reverse embargoes are both > 0
                                (reverse.compareTo(0) == 1 && rightReverse.compareTo(0) == 1))
                            {
                                embargoOverlap = true;
                            }
                            else if (// embargoes are equal and reverse embargoes are equal
                                embargo.compareTo(rightEmbargo) == 0 && reverse.compareTo(rightReverse) == 0) {
                                embargoOverlap = true;
                            }
                            else if (// new and old embargoes are different and reverse embargoes are 0
                                embargo.compareTo(rightEmbargo) != 0 && reverse.compareTo(0) == 0 && rightReverse.compareTo(0) == 0)
                            {
                                embargoOverlap = true;
                            }
                            else if(// embargoes are not equal and reverses are not equal and one of the rights has 0s
                                (embargo.compareTo(rightEmbargo) != 0 && reverse.compareTo(rightReverse) != 0)
                                && ((embargo.compareTo(0) == 0 & reverse.compareTo(0) == 0) 
                                    || (rightEmbargo.compareTo(0) == 0 & rightReverse.compareTo(0) == 0)
                                    )
                                ) {
                                embargoOverlap = true;
                            }
                        
                            if (embargoOverlap) {
                                boolean formatOverlap = false;
                                boolean methodOverlap = false;
    
                                // check method and format
                                // if the compared right has at least one format and one method in common with the current right
                                // there is an overlap
                                RowIterator rightCats = right.getTitleRecordRightCategory();
                            
                                categories.reset();
                                while (categories.hasNext()) {
    
                                    TracsBaseEntity category = (TracsBaseEntity)categories.next();
                                    rightCats.reset();
                                    while (rightCats.hasNext()) {
                                        TitleRecordRightCategoryImpl rightCat = (TitleRecordRightCategoryImpl)rightCats.next();
    
                                        if 
                                        (
                                          ( // check if category id, value and permit flag are all equal
                                              ((Number)category.getAttribute("CategoryId")).compareTo(rightCat.getCategoryId()) == 0
                                              && 
                                              ((String)category.getAttribute("Value")).equalsIgnoreCase(rightCat.getValue())
                                              && 
                                              ((String)category.getAttribute("PermitFlag")).equalsIgnoreCase(rightCat.getPermitFlag())
                                          )
                                          ||  // OR
                                          ( // check if category id and permit flag are equal 
                                            (
                                              ((Number)category.getAttribute("CategoryId")).compareTo(rightCat.getCategoryId()) == 0
                                              && 
                                              ((String)category.getAttribute("PermitFlag")).equalsIgnoreCase(rightCat.getPermitFlag())
                                            )
                                            && // and
                                            (
                                              (// the new category is 'Online & Email' with an old category of 'Online' or 'Email'
                                                ((String)category.getAttribute("Value")).equalsIgnoreCase("Online & Email")
                                                && 
                                                (
                                                  (
                                                    ((String)rightCat.getAttribute("Value")).equalsIgnoreCase("Online")
                                                    || 
                                                    ((String)rightCat.getAttribute("Value")).equalsIgnoreCase("Email")
                                                  )
                                                )
                                              )
                                              || // or
                                              (// the old category is 'Online & Email' with a new category of 'Online' or 'Email'
                                                ((String)rightCat.getAttribute("Value")).equalsIgnoreCase("Online & Email")
                                                && 
                                                (
                                                  (
                                                    ((String)category.getAttribute("Value")).equalsIgnoreCase("Online")
                                                    || 
                                                    ((String)category.getAttribute("Value")).equalsIgnoreCase("Email")
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        ) {
                                            
                                            if (((Number)category.getAttribute("CategoryId")).compareTo(1) == 0) {
                                                formatOverlap = true;
                                            }
                                            else if (((Number)category.getAttribute("CategoryId")).compareTo(2) == 0) {
                                                methodOverlap = true;
                                            }
                                        } // category match check
                                    }  // compare right categories loop
                                }  // current right categories loop
                                
                                if (formatOverlap && methodOverlap) {
                                    overlap = true;
                                }
                            
                            }  // end embargoOverlap check
                        }  // end date overlap check
                    }  // end self check
                
                    if (overlap) {
                        return false;
                    }
                }  // end rights loop
            }  // end categories rowcount check
        }  // end object status check
        return true;
    }       // end validateTraxTitleRecordRightOverlap

    /**Gets the associated entity oracle.jbo.RowIterator
     */
    public RowIterator getTitleRecordRightCategory() {
        return (RowIterator)getAttributeInternal(TITLERECORDRIGHTCATEGORY);
    }

    /**Gets the associated entity RightTemplateImpl
     */
    public RightTemplateImpl getRightTemplate() {
        return (RightTemplateImpl)getAttributeInternal(RIGHTTEMPLATE);
    }

    /**Sets <code>value</code> as the associated entity RightTemplateImpl
     */
    public void setRightTemplate(RightTemplateImpl value) {
        setAttributeInternal(RIGHTTEMPLATE, value);
    }

    /**
     * Validation method for TitleRecordRight.
     */
    public boolean validateTitleRecordRightRestriction() {
        if ((this.getEntityState() != this.STATUS_NEW && this.getEntityState() != this.STATUS_DEAD && this.getEntityState() != this.STATUS_DELETED)
            && (this.getRightType().equalsIgnoreCase("restriction"))
        ) {
            RowSet categories = (RowSet)getTitleRecordRightCategory();
            boolean hasRestriction = false;
            
            if (categories != null) {
                while (categories.hasNext()) {
                    TitleRecordRightCategoryImpl category = (TitleRecordRightCategoryImpl)categories.next();
                    if (category.getCategoryId().compareTo(3) == 0) {
                        hasRestriction = true;
                    }
                }   // end while
            }
            
            if (!hasRestriction) {
                // the Right is not complete
                return false;
            }
        }
        
        return true;
    }

    /**
     * @param id key constituent

     * @return a Key object based on given key constituents.
     */
    public static Key createPrimaryKey(Number id) {
        return new Key(new Object[]{id});
    }


}
